\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=2.5cm]{geometry}
\usepackage{graphicx}
\usepackage{float}
\usepackage{xcolor}
\usepackage{listings}
\lstset{escapeinside={<@}{@>}}
\usepackage{hyperref}

\graphicspath{ {./images/} }

\title{DNS laboratory - Group 2}
\author{Carlo Ramponi, Luca De Menego, Matteo Zanotto}
\date{04 May 2022}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\begin{document}
\begin{titlepage}

\centering
    \vfill
    \vskip3cm
    \Large Department of Information Engineering and Computer Science
    \vskip0.5cm
    \Large (DISI)
    \vskip2cm
    \includegraphics[width=8cm]{logo_unitn.png}
    \vskip2cm
    \textbf{\Large Network Security - A.Y. 2021/2022}
    \vskip2cm
    \textbf{\LARGE DNS}
    \vskip0.2cm
    \textbf{\LARGE Cache poisoning and Kaminsky attack}
    \vskip4cm
    \Large Carlo Ramponi, Luca De Menego, Matteo Zanotto
    \vfill

\end{titlepage}

\clearpage

\tableofcontents

\clearpage

\section{DNS specification}

\subsection{What is the DNS}

The \emph{Domain Name System} is a fundamental Internet service that maps human readable host names, such as \texttt{disi.unitn.com}, to IP addresses, such as \texttt{193.205.194.4}, that can actually be used by machines in networking.

\noindent
More generally, the DNS was developed to provide a consistent name space for referring to internet resources such as host domain names or mailboxes.

\noindent
It defines standard formats for representing the resource data and for methods to query the database.

\hfill \break
\noindent
The DNS was developed with scalability in mind to adapt to the increasing sheer size of internet data and usage: it is implemented in a distributed hierarchical manner as a tree structure, where more fine grained information about the resources is accessed by walking down a delegation mechanism.

\noindent
Additionally, local caching is applied to improve the performances: already known information is stored so it can be served directly without repeating queries.

\subsection{Typical DNS messages flow}
DNS queries typically follow a redirect flow between various name servers along the hierarchy until the resource is resolved. This is because each name server either answers the question posed in the query or refers the requester to another set of name servers when it is not able to resolve the query.

\hfill \break
\noindent
In a typical name resolution scenario, a DNS query will be generated by the client on the browser when trying to connect to a domain. The query will be received by a DNS recursive resolver, which will handle the query until a final response to return to the client. Assuming caches are empty, the recursive server will contact a root name server at the top of the hierarchy which will return a set of addresses for top level domain (TLD) name servers responsible for the input domain name. TLD name servers maintain information on domains that share the same domain extension, such as \texttt{.com}, \texttt{.it}, \texttt{.net} etc.

\noindent
The resolver will redirect the query to a top level domain server which will return the address of an authoritative name server: this is the final step of the name resolution as the authoritative server contains the specific information about the input domain address, it will not redirect the query to another name server.

\noindent
Once the resolver receives the answer from the authoritative name server the domain name is resolved to an IP address to which the client can finally connect.

\hfill \break
\noindent
Each interaction between the recursive resolver and the other name servers is identified by a query ID, that is generated by the resolver and is required to have the same value for both question and answer messages. This is a lightweight authentication mechanism that allows a recursive resolver to actually know that it is receiving a reply from a name server about the question it has sent. Responses that don't match the query ID will be discarded by the resolver, while legitimate responses are stored in the cache.

\subsection{DNS messages format}
A DNS packet is structured as a message with an header containing a set of always present fixed fields and a four section data content.

\hfill \break
\noindent
The header fields contain the 16 bit query ID, a flag for signaling the packet is a question or an answer, an opcode that identifies the type of the dns message, a flag for signaling recursion between name servers is desired in the name resolution process, a flag signaling the answer comes from an authoritative name server. Then there are a set of numbers that indicate the number of entries and authorities in the question or in the response. There are also fields for error handling.

\hfill \break
\noindent
The data content differs depending if it is a question or an answer but is generally structured in four sections for question data, answer data, authority data and additional data. 
In a question message there would be a \texttt{qname} field for the domain that needs to be resolved, a \texttt{qtype} field for the type of query (which is typically A for host addresses, NS for name server addresses, MX for mail servers) and a \texttt{qclass} field that specifies the query class, almost always with value IN as it refers to internet queries.

\noindent
An answer message will contain different data in the answer section depending on the type of resource that is returned. For example, in case of a domain name resolution with a \texttt{A} type it will contain the domain name, the IP address and the time to live of the information, while a redirection to another name server will contain a \texttt{NS} type answer with the name of the name server in the authority section together with an \texttt{A} type answer for the address of the name server in the additional information.

\hfill \break
\noindent
A DNS message is typically carried over a UDP packet for the fast performance requirements of the service.

\subsection{Resources representation}
All DNS data is stored in a core data structure called Resource Record (RR) which is internally composed of a series of fields and is identified by a name.

\hfill \break
\noindent
The fields of resource record are:
\begin{itemize}
\item Type, which specifies the abstract type of the resource in this resource record. The most common types are \texttt{A} for domain addresses, \texttt{NS} for name servers of a domain, \texttt{SOA} for authority information and \texttt{MX} for mail exchanges.
\item Class, for the protocol that it refers to, almost always with value \texttt{IN} for internet.
\item Rdata, for type and class depending data of the resource record. For example, in case of an A type resource record, it will be an IP address while for an NS resource record it will be a domain name.
\item TTL, the time to live of the information on the cache
\item Owner, often implicit
\end{itemize}

\hfill \break
\noindent
Since DNS resolvers query for a name, class and type, they are inherently querying for resource records.

\section{DNS implementation: Bind}

\subsection{Bind configuration}

\subsection{Zone files}

\section{Laboratory introduction}

\subsection{Katharà}

\subsection{Laboratory network topology}

\begin{figure}[h!]
  \centering
  \includegraphics[width=16cm]{network-topology.png}
  \caption{Laboratory network topology}
\end{figure}

\section{DNS Cache Poisoning}

\subsection{Attack introduction}
In this first exercise we will focus on a DNS Cache Poisoning attack. The main idea behind it is to inject wrong information into a recursive nameserver's cache. In our case, in particular, we will try to map, inside the target DNS' cache, the domain \texttt{foo.example.com} to the attacker's malicious website.

In order to perform such an attack, it is obviously not enough to send random DNS responses with the chosen \texttt{A} record: the DNS will only accept \textbf{valid} responses \textbf{to pending queries}. The most important fields our fake response will need to match are:
\begin{itemize}
    \item the source port: the chosen UDP source port for the communication between two entities;
    \item the query ID: a unique identifier assigned when the query was created;
    \item the query section: every response must contain a copy of the original request.
\end{itemize}

\subsection{The attack in details}
\label{subsec:attack-details}

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{cache-poisoning-attack.png}
    \caption{Cache Poisoning Attack scheme}
    \label{fig:cache-poisoning-attack}
\end{figure}

Before diving into the implementation, it is crucial to understand how the attack will be performed. Following Figure \ref{fig:cache-poisoning-attack}, the attack can be represented with 6 steps:
\begin{enumerate}
    \item the attacker asks to the victim recursive nameserver what is the \texttt{A} record for \texttt{foo.example.com};
    \item the recursive nameserver, since it doesn't know the answer, asks it to the Top Level Domain nameserver for \texttt{.com};
    \item the TLD nameserver answers with: 
    \begin{itemize}
        \item a NS record, stating that the authoritative nameserver for the requested domain is \texttt{ns.example.com};
        \item an A record mapping \texttt{ns.example.com} to its IP address \texttt{2.2.2.254}.
    \end{itemize}
    \item now the recursive DNS can ask, for the last time, what is the A record for \texttt{foo.example.com} to the authoritative nameserver;
    \item a \textbf{race condition} takes place:
    \begin{itemize}
        \item the authoritative nameserver replies with the correct A record, containing \texttt{2.2.2.2};
        \item the attacker tries to guess the transaction ID of the last query, sending fake responses stating that \texttt{foo.example.com} is at \texttt{1.1.1.3}, a malicious webserver controlled by the attacker.
    \end{itemize}
    \item finally, the recursive nameserver will answer the attacker with the \texttt{A} record it got first.
\end{enumerate}

\noindent
At the end of this process, if the attacker is able to correctly guess the query ID and send the fake response before the real authoritative nameserver, the attack succeeds. Notice that an important assumption was made, since we decided to fix the source port to \texttt{33333}, to simulate the original attack. In Section \ref{sec:final-considerations} additional information can be found about this.



\subsection{Sniff a legitimate communication}
The explained flow can be easily sniffed and analyzed with some basic command line tools. Let's try to reconstruct it from a legitimate DNS query.

First of all, open one terminal, connect to the recursive DNS and start listening to UDP packets:
\begin{lstlisting}
 <@\textcolor{codegray}{:>}@> kathara lstart  <@\textcolor{codegreen}{\# Start the laboratory if you haven't already}@>
 <@\textcolor{codegray}{:>}@> kathara connect rec_dns <@\textcolor{codegreen}{\# Connect to the recursive DNS}@>
 <@\textcolor{codegray}{rec-dns :>}@> tcpdump -vv udp port 53    <@\textcolor{codegreen}{\# Start listening to all udp packets}@>
\end{lstlisting}

Now open another terminal, connect to the victim and gather DNS information on \texttt{hi.example.com} using the \texttt{dig} utility:
\begin{lstlisting}
 <@\textcolor{codegray}{:>}@> kathara connect victim <@\textcolor{codegreen}{\# Connect to the victim's machine}@>
 <@\textcolor{codegray}{victim :>}@> dig hi.example.com    <@\textcolor{codegreen}{\# Gather DNS information on hi.example.com}@>
\end{lstlisting}

The result of \texttt{tcpdump} is shown in Figure \ref{fig:tcpdump-res}. The flow is clearly the same as the one explained in Subsection \ref{subsec:attack-details}, without the attacker's manipulation involved. It is important to note that the query IDs are always respected between requests and replies, and here the final response of the authoritative server contains the correct \texttt{A} record.

One only thing is still missing: the response from the recursive nameserver to the client. This is available in the \texttt{dig}'s response, visible from Figure \ref{fig:dig-res}. Apart from the sections' result, that at this point should be clear, you should see the same Query ID of the first request in the \texttt{tcpdump} output.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{tcpdump-res.png}
    \caption{tcpdump's result}
    \label{fig:tcpdump-res}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{dig-result.png}
    \caption{dig's result}
    \label{fig:dig-res}
\end{figure}

\subsection{The Workspace}

Inside the lab directory you will find a \textbf{shared folder}, common to all Kathará machines. All updates performed to the files inside this folder will be immediately visible by everyone. This means that you can:
\begin{itemize}
    \item work on the scripts inside it from the host machine, with the editor you want;
    \item when you are ready, connect to the attacker's machine with \texttt{katahra connect attacker};
    \item compile the script with \texttt{g++ -o script-name /shared/script-name.cpp -ltins};
    \item run it with \texttt{./script-name}
\end{itemize}

\noindent
All the scripts are written in C++, and for packet crafting the \texttt{libtins} library has been used, which provides an easy-to-use and efficient platform for manipulating network packets.

\subsection{Implementation of the attack}
The cache poisoning implementation is available inside the \texttt{cache-poisoning.cpp} file, in the script folder. Following the flow explained in subsection \ref{subsec:attack-details}, in the first part a DNS query for is created. In particular, as shown in Figure \ref{fig:cache-poisoning-first}:
\begin{itemize}
    \item the type of the request is set to \texttt{DNS::QUERY};
    \item the query ID can be any number we want, since we are creating the query ourselves;
    \item the recursion is allowed, hence the recursive DNS will recursively ask the same query to upper-level nameservers;
    \item the actual query will be for the \texttt{A} record of \texttt{foo.example.com};
    \item the final packet is constructed, composed by three parts: IP, UDP and DNS.
\end{itemize}

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{cache-poisoning-first.png}
    \caption{First part of the cache poisoning script: generate a DNS query}
    \label{fig:cache-poisoning-first}
\end{figure}

\noindent
In the second part of the script available in Figure \ref{fig:cache-poisoning-second}, instead, we will try to guess the Query ID, sending fake packets containing the malicious A record. Here the main steps are the following:

\begin{itemize}
    \item loop through every possible Query ID, creating a packet for each one of them;
    \item set the type of the DNS packet to \texttt{DNS::RESPONSE};
    \item set the current Query ID of the loop;
    \item allow the recursion, for the same reason as before;
    \item add the original query into the packet, as any DNS response without the corresponding query will be simply dropped by a DNS server;
\end{itemize}

\noindent
In order to finalize the script, we need to complete the DNS answer and initialize the IP packet correctly:
\begin{enumerate}
    \item \textbf{DNS answer creation}: what we want to achieve is a DNS \texttt{A} record stating that the domain \texttt{foo.example.com} should resolve to \texttt{1.1.1.3}. So the first parameter must be set to \texttt{ATTACKING\_DOMAIN}, and the second to \texttt{MALICIOUS\_WEBSERVER};
    \item \textbf{IP packet completion}: we want to send this fake response to the recursive DNS, pretending to be the legitimate authoritative nameserver it contacted. Since the first parameter represents the destination and the second one the source, we should put respectively \texttt{RECURSIVE\_DNS}, \texttt{AUTHORITATIVE\_DNS}.
\end{enumerate}

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{cache-poisoning-second.png}
    \caption{Second part of the cache poisoning script: try to guess the Query ID and poison the cache of the target DNS}
    \label{fig:cache-poisoning-second}
\end{figure}

\subsection{Final Steps}
\noindent
Before compiling and running the attack, however, there is one important step missing. We want to be sure to win the race condition against the real authoritative DNS. That's why we will cheat a little bit, by adding a delay to it:
\begin{lstlisting}
 <@\textcolor{codegray}{:>}@> kathara connect authoritative_dns  <@\textcolor{codegreen}{\# Connect to the authoritative DNS}@>
 <@\textcolor{codegray}{authoritative-dns :>}@> tc qdisc add dev eth0 root netem delay 1500ms    <@\textcolor{codegreen}{\# Add delay}@>
\end{lstlisting}
\noindent
Now that the probability of success has increased a lot, we can compile and run the attack:
\begin{lstlisting}
 <@\textcolor{codegray}{:>}@> kathara connect attacker  <@\textcolor{codegreen}{\# Connect to the attacker's machine}@>
 <@\textcolor{codegray}{attacker :>}@> g++ -o cache-poisoning /shared/cache-poisoning.cpp -ltins    <@\textcolor{codegreen}{\# Compile}@>
 <@\textcolor{codegray}{attacker :>}@> ./cache.poisoning    <@\textcolor{codegreen}{\# Run}@>
\end{lstlisting}

\noindent
Since we are guessing the Query ID, the probability of success is clearly not 100\%. To verify whether the attack was successful or not there are two main ways:
\begin{enumerate}
    \item check the cache of the recursive DNS. You should see an A record for \texttt{foo.example.com} mapped to \texttt{1.1.1.3}.
    \begin{lstlisting}
     <@\textcolor{codegray}{:>}@> kathara connect rec_dns  <@\textcolor{codegreen}{\# Connect to the recursive DNS}@>
     <@\textcolor{codegray}{dns :>}@> rndc dumpdb -cache && grep "example.com" /var/cache/bind/dump.db     
     
     [...]
     foo.<@\textcolor{red}{example.com}@>.  259172  A   1.1.1.3
     [...]\end{lstlisting}
     \item check the effect on the victim's side by using \textit{links}, a simple console browser:
     \begin{lstlisting}
     <@\textcolor{codegray}{:>}@> kathara connect victim  <@\textcolor{codegreen}{\# Connect to the victim's machine}@>
     <@\textcolor{codegray}{victim :>}@> links    <@\textcolor{codegreen}{\# Launch the browser}@>\end{lstlisting}
     Type \textbf{'g'} and search \texttt{'http://foo.example.com'}. You should be redirected to the attacker's website, as can be seen in Figure \ref{fig:attacker-website}.
\end{enumerate}

\noindent
If in your case it didn't work, keep retrying: after some trials you should be able to guess the correct Query ID. You can even try to play with the delay: incrementing it would mean increasing your probability of success.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{attacker-website.png}
    \caption{The attacker's website, visible after a correct execution of the cache poisoning attack}
    \label{fig:attacker-website}
\end{figure}

\newpage
\section{Kaminsky Attack}

\section{Final considerations}
\label{sec:final-considerations}

\subsection{Performing the attack nowadays}

\subsection{DNSSEC}

\end{document}